## 1、spring循环依赖问题

**解决循环依赖**

- lazy延迟加载
- 三级缓存



## 2、三级缓存

- `singletonObjects`：一级缓存，存储的是创建好的bean对象。
- `earlySingletonObjects`：二级缓存，存储的是尚未完全创建好的bean对象
- `singletonFactories`：三级缓存，存储的是单例bean的对象工厂，实际就是一个lambda表达式，用于创建这个bean



### 2.1 **创建bean对象的流程**

Bean的创建流程：实例化 --> 设置属性值 --> 初始化

- 创建一个A对象时，会先从一级缓存中获取，如果一级缓存中存在，那么直接返回。否则创建A对象，设置属性值时发现需要B对象，此时执行创建B对象的流程，先从一级缓存中查找B对象，发现没有，就去创建B对象，完成B对象的创建后，将B对象放入一级缓存，然后赋值给A对象，A对象创建成功，放入一级缓存

```
@Service
public Class A {
	@Autowire
	private final B b;
}

@Service
public Class B {
}
```



### 2.2 **通过三级缓存创建bean对象，解决循环依赖问题**

- 创建一个A对象时，会先从一级缓存中获取，如果一级缓存中存在，那么直接返回。否则实例化A对象，同时将A对象的对象工厂放入三级缓存中，这个对象工厂其实就是一个lambda表达式，用于创建A对象使用
  - 设置属性值时发现需要B对象，此时执行创建B对象的流程。
  - 先从一级缓存中查找B对象，发现没有，就去创建B对象，完成B对象的实例化后，将B对象的对象工厂放入三级缓存
  - 设置属性值时发现B对象需要注入A对象，先去一级缓存查询A对象，没找到，但是发现A对象状态为创建中，即保存在`Creating Set`中，此时去二级缓存查询，查询不到就去三级缓存查询，在三级缓存中通过A的对象工厂来创建A对象，此时是一个半成品对象，创建完之后，将其放入二级缓存，然后把A对象注入到B中，此时B对象初始化成功，B对象存入一级缓存，然后将三级缓存中B对象的对象工厂删除。
- B对象创建成功后，将B对象注入到A对象中，A对象创建成功，放入一级缓存，同时删除二级缓存中A对象的半成品和三级缓存中A对象的对象工厂

```java
@Service
public Class A {
	@Autowire
	private final B b;
}

@Service
public Class B {
	@Autowire
	private final A a;
}
```

![](https://cdn.jsdelivr.net/gh/xrj123123/Images/202408280035202.png)







### 2.3 二级缓存解决循环依赖

如果循环依赖的bean对象不是代理对象，那么通过二级缓存就可以解决循环依赖问题。代理对象是在`BeanPostProcess`的后置处理方法中进行创建的

![](https://cdn.jsdelivr.net/gh/xrj123123/Images/202408280038890.png)

- 创建A对象时，先进行实例化，实例化后，就将A对象放入二级缓存，即半成品池中。
- 然后注入B对象，发现一级缓存即单例池中不存在B对象，那么就去创建B对象，B对象实例化后，需要注入A对象，此时一级缓存中找不到，在二级缓存中找到了A对象，那么就注入
- 此时B对象创建完成，放入一级缓存，然后A对象就可以注入B对象，A对象创建完成，放入一级缓存中





### 2.4 AOP代理对象的循环依赖

spring使用三级缓存是为了解决代理对象之间的依赖问题，如果A和B都被代理了，那么放入IOC容器的就是A和B的代理对象。因为创建代理对象是在`BeanPostProcess`的后置处理方法中进行的，所以二级缓存就无法解决这个问题，此时就需要三级缓存来解决。



通过`BeanPostProcess`创建代理对象有两种方式

- `postProcessAfterInitialzation`：在`BeanPostProcess`的后置处理器中创建代理对象
- `getEarlyBeanReference`：提前创建代理对象。即实例化对象时，将该对象的对象工厂放入三级缓存，这个lambda表达式就可以通过`getEarlyBeanReference`来提前创建代理对象。如果发生了循环依赖，该对象需要被提前创建时，才会执行提前创建的方法。如果没有发生循环依赖，就不会执行该方法提前创建

![](https://cdn.jsdelivr.net/gh/xrj123123/Images/202408272353256.png)

- spring就是通过三级缓存，提前创建代理对象的方式，解决代理对象之间的循环依赖问题。
- 如果bean对象没有被AOP代理，那么创建的就是普通对象。如果被AOP代理了，创建的才是代理对象





### 2.5 三级缓存解决循环依赖的限制

#### 2.5.1 必须是单例的bean

- Spring循环依赖的解决方案主要是通过对象的提前暴露来实现的。当一个对象在创建过程中需要引用到另一个正在创建的对象时，Spring会先提前暴露一个尚未完全初始化的对象实例，以解决循环依赖的问题。这个尚未完全初始化的对象实例就是半成品对象。

- 在Spring容器中，单例对象的创建和初始化只会发生一次，并且在容器启动时就完成了。这意味着，在容器运行期间，单例对象的依赖关系不会发生变化。因此，可以通过提前暴露半成品对象的方式来解决循环依赖的问题。
- 相比之下，原型对象的创建和初始化可以发生多次，并且可能在容器运行期间动态地发生变化。因此，对于原型对象，提前暴露半成品对象并不能解决循环依赖的问题，因为在后续的创建过程中，可能会涉及到不同的原型对象实例，无法像单例对象那样缓存并复用半成品对象
  

#### 2.5.2 不能使用构造器注入

Spring无法解决构造函数的循环依赖，是因为在对象实例化过程中，构造函数是最先被调用的，而此时对象还未完成实例化，无法注入一个尚未完全创建的对象，因此Spring容器无法在构造函数注入中实现循环依赖的解决。



#### 2.5.3 @Lazy

可以使用`@Lazy`注解解决构造器注入时循环依赖的问题

- `@Lazy` 是Spring框架中的一个注解，用于延迟一个bean的初始化，直到它第一次被使用时才创建。

- 在默认情况下，Spring容器会在启动时创建并初始化所有的单例bean。这意味着，即使某个bean直到很晚才被使用，或者可能根本不被使用，它也会在应用启动时被创建。`@Lazy`注解就是用来改变这种行为的，用于延迟一个Bean的初始化

- 当我们使用`@Lazy`注解时，Spring容器会在需要该bean的时候才创建它，而不是在启动时。这意味着如果两个bean互相依赖，可以通过延迟其中一个bean的初始化来打破依赖循环。
  

假设我们有两个类ClassA和ClassB，它们之间存在循环依赖。我们可以使用@Lazy 来解决这个问题

> 在这个例子中，A的构造器依赖B，但我们使用了`@Lazy `注解来标记这个依赖。这意味着B的实例会在首次被实际使用时才创建，而不是在创建A的实例时。这样，Spring容器可以先创建 A的实例(此时不需要立即创建B)，然后创建B的实例，最后解决A对B的依赖。

```java
@Component
public class A {
    private B b;
    
    @Autowire
    public A(@Lazy B b) {
        this.b = b;
    }
}

@Component
public class B {
    private A a;
    
    @Autowire
    public B(A a) {
        this.a = a;
    }
}
```







### 3、spring中，bean加载前后执行一些逻辑

1、使用`init-method`和`destory-method`方法，bean的类内部创建初始化和销毁方法，然后通过`init-method`和`destory-method`指定，这样创建bean对象时，就会执行这两个方法

2、实现`InitializingBean`和`DisposableBean`接口，分别实现`afterPropertiesSet`和`destory`方法

3、使用`@PostConstruct`和`@PreDestory`注解修饰类中的方法

