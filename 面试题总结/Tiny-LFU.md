Java中可以使用ConcurrentHashMap作为缓存，第三方缓存都是基于ConcurrentHashMap做扩展的。第三方缓存为了实现这些扩展功能，必须在ConcurrentHashMap 上做一些额外的操作，比如读取数据的时候要记录一些读取行为，以便于后期作为缓存淘汰缓存数据的分析。 在写入数据的时候同时也要记录一些信息，根据对应的信息触发后期的事件。而记录这些数据的操作就成了一个性能负担了

- Ecache和Guava在数据写入和读取的时候都是同步记录这些附加信息的，因为容器本身读写都需要进行加锁，而这些附加操作又是在加锁的操作内的，所以就必然会降低容器本身的性能。

- cafeine中采用了异步的模式，读写记录的额外信息都是采用异步的方式写入到日志的，这样就尽可能的减少了记录附加信息对容器本身的影响。 在ConcurrentHashMap读写数据的时候并不会马上写入这些附加信息，而是会把这些信息放到一个环形缓冲区中再异步的执行，缓存区设置了一个固定的大小，在写入数据的缓冲区满了，那么就必须同步写入

![img](https://pic4.zhimg.com/v2-9145c66300dc1b57270ce0c467330d95_r.jpg)





### LRU和LFU的缺点

**LRU**

- 无法避免热点数据问题，有些缓存数据可能只在某一时间段访问频率高，平常并不会经常访问，一旦到对应的时间点就会被大量使用，而使用LRU策略的话就会把这部分的数据淘汰掉。
- 存在缓存污染的问题



**LFU**

- LFU要为每个缓存key维护一个计数器，如果Key的数量特别多，维护每个缓存的计数器需要大量的内存资源
- LFU 无法识别突发性的流量，比如某个数据在一段时间内大量访问，之后就不再使用了。而由于该缓存统计的访问次数太多，导致这个缓存后期无法淘汰





### SLRU

SLRU就是把缓存分成两段，一段是`淘汰段`，一段是`保护段`，两个段都是普通的LRU实现。第一次被访问的元素将进入淘汰段，只有处于淘汰段中的元素再次被访问才会进入保护段。保护段中的元素如果被淘汰将会再次进入淘汰段，而淘汰段的元素被淘汰则会被移出缓存





### TinyLFU

为了减少维护计数器带来的额外存储负担，TinyLFU 在LFU的基础上对计数器的功能进行了优化，TinyLFU 使用了一种**Count–Min Sketch** 算法，其核心思想类似于布隆过滤器，使用最小的资源代价来记录最多的数据。



**CountMinSketch**

`CountMinSketch`计数器的数据结构是一个二维数组，每一个元素都是一个计数器，计数器可以使用一个数值类型进行表示，比如`无符号int`，对于增加计数操作，每个元素会通过不同的哈希函数映射到每一行的某个位置，并增加对应位置上的计数。估数计算根据哈希映射到每一行的对应位置，然后读取所有行的计数，返回其中最小的一个。

> 返回最小的是因为其他元素也可能会映射到自身所映射位置上面，导致计数比真实计数大，因此最小的一个计数最可能是真实计数

![哈希映射.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5328513b81344859a5aa2302a305c24c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)



**TinyLFU**

- 由于计数值有上限，因此我们不需要为每个计数器分配太多内存，通常只需要分配 4 个 bit 位作为计数器统计每个元素的频率，减少计数所消耗的内存空间
- 使用半衰期思路，设定一个计数上限 w，当任意计数达到了 w，则将所有计数除 2，这称之为 Reset。

- TinyLFU应对突发的稀疏流量时表现不佳。这些稀疏流量的访问频次不足以让他们在LFU缓存中占据位置，很快就又被淘汰了



### W-TinyLFU

Window-TinyLFU策略里包含LRU和LFU两部分

- 前端的LRU叫做`Window LRU`，它的容量只占据**1%**的总空间，它的目的就是用来存放短期的突发访问数据。
- 后端的为`Segmented LRU`(SLRU)，占据总空间的99%。SLRU包含2个固定尺寸的LRU，一个叫Probation段A1，一个叫Protection段A2。新记录总是插入到A1中，当A1的记录被再次访问，就把它移到A2，当A2满了需要驱逐记录时，会把驱逐记录插入到A1中。W-TinyLFU中，SLRU有80%空间被分配给A2段。

![2022090808585803.jpg](https://img.jbzj.com/file_images/article/202209/2022090808585803.jpg)

1、窗口缓存

> 新添加的key都放入窗口缓存。
>
> - W-TinyLFU选择一个元素是否加入缓存，得看这个元素加入缓存能否提高整体缓存的命中率，而这个评估的依据就是根据元素的频率。但是如果一个刚加入缓存的元素（表示元素刚刚才开始被访问），它的频率并不足以让它加入缓存，那么它会直接被淘汰。
>
> - 因此在W-TinyLFU中使用LRU来作为一个`窗口缓存`，主要是让元素能够有机会在`窗口缓存`中去积累它的频率，避免因为频率很低而直接被淘汰。

2、主缓存

> 主缓存使用的是SLRU，Protection占80%，Probation占20%



3、过滤器

过滤器基于CountMinSketch，用来统计频率，当窗口缓存中一个key被淘汰，那么他将进入主缓存中，如果主缓存满了，也需要淘汰一个key，此时就通过Filter计算这两个key的频次，将频次低的淘汰。



4、衰减策略

当某个key的频次达到一个阈值时，就会将所有key的频次减半

